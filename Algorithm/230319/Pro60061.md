문제링크 : [https://school.programmers.co.kr/learn/courses/30/lessons/60061](https://school.programmers.co.kr/learn/courses/30/lessons/60061)

### 문제 해결 과정

1. 특정한 알고리즘을 사용하는 것이 아닌 문제에서 주어진 조건에 맞게 코드를 **구현**할 수 있는지 묻는 문제인 것 같다.
2. 문제에서 설명을 위해 사용한 그림을 보면 평소에 우리가 사용하는 배열의 모습이 아닌 수학에서의 `x` 축 `y` 축 개념으로 생각해야 하기 때문에 방향을 잘 생각해야 한다.
3. 기둥과 보가 특정 좌표에 설치가 되어 있는지 확인하기 위해 3차원 배열 `map` 을 만들어 주었다.
   `map[x][y][0]` 은 `(x,y)` 에 기둥이 설치되어 있는가 `map[x][y][1]` 은 `(x,y)` 에 보가 설치되어 있는가 값이 `0` 이면 설치되어 있지 않음, `1` 이면 설치되어 있음을 뜻한다.
4. 문제에서 주어진 `build_frame` 배열에 대해서 `for loop` 를 통해 순회하면서 설치를 하는 경우 기둥또는 보를 설치할 수 있는지 확인하는 함수를 각각 생성하여 각 함수에서 `return` 되는 값이 `true` 면 `map` 의 값을 `1` 로 바꾸어 주는 작업을 한다.
5. 제거하는 경우라면 먼저 해당 좌표에 대해서 기둥 또는 보에 대한 `map` 값을 `0` 으로 만들어주고 주변 다른 구조물들이 여전히 설치가 가능한지 확인하는 함수를 만들고 체크해준다.
6. 마지막으로 설치되어 있는 구조물들을 `x` 좌표에 대한 오름차순 같은 경우 `y` 좌표에 대한 오름차순 이마저도 같은 경우 기둥이 먼저 정렬되게 하여 출력한다.

### 문제 해결 코드

### 1. 기둥과 보 설치 여부 정보를 담는 3차원 배열

3차원 배열 `map` 은 설치 가능 여부를 검사하는 함수 그리고 제거 가능 여부를 검사하는 함수에서 쓰이므로

전역변수로 관리하여 인수로 계속 넘기는 불편함을 제거하도록 하였다.

```tsx
map = Array.from(Array(n + 1), () =>
  Array.from(Array(n + 1), () => Array(2).fill(0))
);
```

### 2. 해당 기둥이 설치가 가능한지 판별하는 함수

> 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 한다.

4가지 조건에 대해서 생각할 수 있다. 여기서부터 혼동이 될 수 있는데 수학에서의 `x` 축 `y` 축을 생각해보면

바닥에 붙어있다는건 `y` 의 값이 `0` 이라는 것을 인지해야 한다. 또한 왼쪽 오른쪽은 `x` 축의 값이 `-1` 또는 `+1` 된다는 것을 인지해야한다.

1. 해당 기둥이 바닥에 설치되는가? `y` 좌표가 `0` 인 경우
2. 보의 한쪽 끝 부분에 있다. 보의 설치는 주어진 좌표를 기준으로 오른쪽 방향 즉 `x` 축으로 `+` 방향으로 설치된다. 이를 인지한 상태에서 설치하려는 기둥이 자신의 왼쪽에서 설치된 보의 끝에 있거나 자신과 같은 좌표에 설치된 보가 있는지 검사를 해야한다.

   2-1. 현재 기둥이 `(1,1)` 에 설치되어 있다고 가정해보자 그렇다면 보가 `(0,1)` 에 설치되어 있다면 그 끝이 `(1,1)` 이므로 기둥이 보의 한쪽 끝 부분 위에 있는 것이다.

   2-2. 현재 기둥이 `(1,1)` 에 설치되어 있다고 가정해보자 그렇다면 보가 `(1,1)` 에 설치되어 있다면 그 끝이 `(2,1)` 인데 이때 기둥 역시 보의 한쪽 끝 이 경우는 `(1,1)` 부분 위에 있는 것이다.

3. 다른 기둥 위에 있어야 한다. 즉 자신보다 `y-1` 부분에 기둥이 설치되어 있는가를 생각하면 된다.

```tsx
const isPillarBuildAble = (x, y) => {
  // 조건 1
  if (y === 0) {
    return true;
  }
  // 조건2 2-1
  if (x > 0 && map[x - 1][y][1] === 1) {
    return true;
  }

  // 조건2 2-2
  if (x < N && map[x][y][1] === 1) {
    return true;
  }

  // 조건3
  if (y > 0 && map[x][y - 1][0] === 1) {
    return true;
  }

  return false;
};
```

### 해당 보가 설치가 가능한지 판별하는 함수

> 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 한다.

1.  보가 한쪽 끝 부분이 기둥위에 있어야 한다. 보가 `(1,1)` 좌표에 설치가 되었다 가정하면 `(1,1) ~ (2,1)` 일 것이다. 이때 기둥의 끝이 `(1,1)` 또는 `(2,1)` 가 되려면 어디에 설치되어야 하는가 생각해봐야 한다.
    바로 `(1,0)` 또는 `(2,0)` 이 되어야 한다.

    1-1. 보가 설치될 좌표에 기둥이 세워져 있는가

    1-2. 보가 설치되는 좌표에서 오른쪽 방향으로 끝이 세워지므로 그 끝부분에 기둥이 있는가

2.  양쪽 끝부분이 다른 보들과 연결되어 있는가를 따지기 위해선 보는 주어진 좌표에서 오른쪽 방향으로 세워진다. 이를 생각하면 현재 보가 설치되는 좌표가 `(1,1)` 이라면 `(0,1)` 과 `(2,1)` 에 보가 설치되어야 한다.

```tsx
const isGriderBuildAble = (x, y) => {
  // 조건 1-1.
  if (map[x][y - 1][0] === 1) {
    return true;
  }
  // 조건 1-2.
  if (map[x + 1][y - 1][0] === 1) {
    return true;
  }

  // 조건 2
  if (x > 0 && x <= N - 2 && map[x - 1][y][1] == 1 && map[x + 1][y][1] === 1) {
    return true;
  }
  return false;
};
```

### 기둥 또는 보를 제거할 수 있는지 판별하는 함수

와! 기둥과 보를 설치하는 작업은 끝이 났다. 이제 삭제를 해야하는데 문제에서 다음과 같은 조건이 있다.

> 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다.

여기서 위 규칙이란 다음과 같다.

> 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 한다.
>
> 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 한다.

기둥 또는 보를 삭제가 가능한지 판별하는 방법은 여러가지가 있는 것 같은데 제일 쉽게 접근할 수 있는 방법은 삭제할 기둥 또는 보에 대해서 `map` 값을 `0` 으로 만들어주고 `map` 값을 모두 순회하면서 `1` 인 경우 위에서 작성한 `isPillarBuildAble` `isGriderBuildAble` 를 이용하면 된다.

```tsx
const isRemoveAble = () => {
  for (let x = 0; x <= N; x++) {
    for (let y = 0; y <= N; y++) {
      for (let t = 0; t <= 1; t++) {
        if (map[x][y][t] === 1) {
          if (t) {
            if (!isGriderBuildAble(x, y)) {
              return false;
            }
          } else {
            if (!isPillarBuildAble(x, y)) {
              return false;
            }
          }
        }
      }
    }
  }
  return true;
};
```

### 결과 출력하기

문제에서 `x` 축에 대한 오름차순, `y` 축에 대한 오름차순, 그 이후 기둥 먼저 출력하라고 하는데 굳이 정렬을 할 필요가 없다고 생각했다. 왜냐하면 다음 코드를 보자.

```tsx
for (let x = 0; x <= N; x++) {
  for (let y = 0; y <= N; y++) {
    for (let t = 0; t <= 1; t++) {
      if (map[x][y][t] === 1) {
        answer.push([x, y, t]);
      }
    }
  }
}
```

이렇게 `answer` 에 값을 넣는다면 문제에서 요구하는 정렬의 과정과 똑같아진다.

### 느낀점

오랜만에 풀어보는 구현문제였다. 구현문제가 어렵게 느껴지는 이유는 2가지 인 것 같다.

1. 문제에서 주어진 내용을 이해할 수 있는가?
2. 문제에서 주어진 제한조건을 고려하여 자신의 생각을 코드로 구현할 수 있는가?

이 문제에서는 추가적으로 어렵게 작용한 요소라면 아무래도 배열처럼 생각하는 것이 아닌 수학의 `x` `y` 좌표처럼 생각하는 과정인 것 같다.

다행히 수학처럼 생각하는 문제를 접해본 경험이 있어서 조금은 편안하게 생각할 수 있었던 것 같다.

문제는 역시 많이 풀면 풀수록 생각하는 범위가 넓어지고 접근을 빠르게 할 수 있는 것 같다.

### 최종 코드

```tsx
let N, map;
function solution(n, build_frame) {
  var answer = [];
  N = n;
  map = Array.from(Array(n + 1), () =>
    Array.from(Array(n + 1), () => Array(2).fill(0))
  );

  for (const [x, y, type, isBuild] of build_frame) {
    // 설치
    if (isBuild) {
      // 보
      if (type) {
        if (isGriderBuildAble(x, y)) {
          map[x][y][type] = 1;
        }
      }
      // 기둥
      else {
        if (isPillarBuildAble(x, y)) {
          map[x][y][type] = 1;
        }
      }
    }
    // 삭제
    else {
      map[x][y][type] = 0;
      if (!isRemoveAble()) {
        map[x][y][type] = 1;
      }
    }
  }

  for (let x = 0; x <= N; x++) {
    for (let y = 0; y <= N; y++) {
      for (let t = 0; t <= 1; t++) {
        if (map[x][y][t] === 1) {
          answer.push([x, y, t]);
        }
      }
    }
  }

  return answer;
}

const isPillarBuildAble = (x, y) => {
  if (y === 0) {
    return true;
  }
  //보의 한쪽 끝 부분 위에 있다, 왼쪽검사
  if (x > 0 && map[x - 1][y][1] === 1) {
    return true;
  }

  //보의 한쪽 끝 부분 위에 있다, 오른쪽검사
  if (x < N && map[x][y][1] === 1) {
    return true;
  }

  // 또 다른 기둥위에 있는 경우
  if (y > 0 && map[x][y - 1][0] === 1) {
    return true;
  }

  return false;
};

const isGriderBuildAble = (x, y) => {
  if (map[x][y - 1][0] === 1) {
    return true;
  }
  if (map[x + 1][y - 1][0] === 1) {
    return true;
  }

  // 양쪽 끝부분이 다른 보들과 연결
  if (x > 0 && x <= N - 2 && map[x - 1][y][1] == 1 && map[x + 1][y][1] === 1) {
    return true;
  }
  return false;
};

const isRemoveAble = () => {
  for (let x = 0; x <= N; x++) {
    for (let y = 0; y <= N; y++) {
      for (let t = 0; t <= 1; t++) {
        if (map[x][y][t] === 1) {
          if (t) {
            if (!isGriderBuildAble(x, y)) {
              return false;
            }
          } else {
            if (!isPillarBuildAble(x, y)) {
              return false;
            }
          }
        }
      }
    }
  }
  return true;
};
```
