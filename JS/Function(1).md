## 함수란

<aside>
💡 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

</aside>

## 함수를 사용하는 이유

- 동일한 작업을 반복적으로 수행하야 한다면 같은 코드를 중복해서 작성하는 것이 아니라 미리 정의된 함수를
  재사용하는 것이 효율적이다. 즉, **코드의 재사용** 측면에서 유용하다.
- 코드 중복 억제, 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높인다.

## 함수는 객체

리터럴은 사람의 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기법이다.

리터럴은 값을 생성하기 위한 표기법이므로, 함수 리터럴도 평가되어 값을 생성한다.

이 때의 값은 객체이다. 즉, **함수는 객체다.**

일반 객체는 호출할 수 없지만 **함수는 호출할 수 있다.**

```jsx
// 변수에 함수 리터럴 할당
let addFunc = function add(a,b){
    return a+b;
}
// 4
console.log(addFunc(1,3));

let multiFunc = function (a,b){
    return a * b; 
}
// 20
console.log(multiFunc(10,2));
```

## 함수 선언문

```jsx
function add(a, b){
    return a + b;
}
let result = add(10, 5);
// 15
console.log(result);
```

### 단, **함수 리터럴은 함수 이름을 생략할 수 있으니 함수 선언문은 함수 이름을 생략할 수 없다.**

**함수 선언문은 표현식이 아닌 문이다.** 따라서 표현식이 아닌 문은 변수에 할당할 수 없다.

```jsx
let subFunc = function sub(a,b){
    return a-b;
}
// 5
console.log(subFunc(10,5));
```

다음 코드를 살펴보면 함수 선언문이 변수에 할당되는 것처럼 보인다.

자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴은 표현식이 아닌 문 즉, 함수 선언문으로 해석하는
경우와 표현식인 문 즉, 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.

함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다.

간단하게 정리하면

> 자바스크립트 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용 즉, 함수 리터럴을 피연산자로 사용하지 않는 경우는 함수 선언문으로 해석하고, 함수 리터럴이 값으로 평가되어야하는 문맥, 즉 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 식으로 해석한다.
>

## 함수 표현식

**자바스크립트의 함수는 일급 객체이다.**

함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당 할 수 있다.

함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용한다.

```jsx
let strJoin = function (catName, catName2){
    return catName + catName2;
}
// 무지막지
console.log(strJoin('무지','막지'));

let divideFunc = function devide(a, b){
    return a / b;
}
// 5
console.log(divideFunc(10, 2));
// divide is not defined
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.
console.log(dividec(10, 2));
```